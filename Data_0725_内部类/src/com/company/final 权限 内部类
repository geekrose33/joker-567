# final
final 不可改变 可以用于修饰类 方法 变量
- 类: 被修饰的类 不能被继承
- 方法： 被修饰的方法 不能被重写
- 变量： 被修饰的变量 不能重新赋值

### 使用
- 修饰类 格式：
```
final class 类名{

}
```
像String Math Scanner这些类都是被final修饰 目的是供我们使用 而不让我们修改

- 修饰方法 格式：
```
修饰符 final 返回值 方法名（参数列表）{
    // 方法体
}
```
如果重写final修饰的方法 编译会报错

- 修饰变量
1. 局部变量 -- 基本类型
    基本类型的局部变量，被final修饰后，只能赋值一次，不能再改
```

```
2. 局部变量 - 引用类型
引用类型的局部变量被final修饰后只能指向一个对象， 但是不影响对象内部
的成员变量值的修改

# 权限修饰符
不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限

- public: 公有的
    具有最大权限

- protected; 受保护的


- default: 默认的


- private: 私有的
    具有最小权限

建议使用权限:
- 成员变量使用 private  隐藏细节
- 构造方法使用 public   方便创建对象
- 成员方法使用 public   方便调用
- 不加权限修饰符 其访问能力与default相同

# 内部类
蒋类A定义在类B中，里边的类A就是内部类 B是外部类
- 成员内部类： 定义在类中 方法外
格式：
```
class 外部类{
    class 内部类{

    }
}
```
在描述事物时 若一个事物内部还包含其他事物 就可以使用内部类这种结构
比如： Car中包含Engine （发动机） Engine就可以使用内部类来描述
```
class Car{
    class Engine{

    }
}
```
### 访问特点
- 内部类可以直接访问外部类的成员 包括私有成员
- 外部类要访问内部类成员 必须要简历内部类对象
创建 内部类对象的格式
```
外部类名.内部类名 对象名 = new 外部类型（）.new 内部类型（）；
```

# 匿名内部类
匿名内部类 时内部类的简化写法 它的本质是一个**带具体实现的** 父类 或者父接口
的匿名子类对象 开发中 最常用到的内部类就是匿名内部类
以接口为例 当你使用一个接口时，似乎需要如下几步：
1. 定义子类
2. 重写接口中所有的方法
3. 创建子类对象
4. 调用重写后的方法
我们的目的是调用方法，那能否简化一下呢？ 蒋四个步骤合为一步呢？
匿名内部类就可以实现
'前提' 匿名内部类必须继承一个父类或者实现一个父接口
格式：
```
new 父类名或者父接口（）{
    // 方法重写
    @Override
    public void method(){
        // 执行语句
    }
}
```
通常在方法的形参是接口或者抽象类的时候 也可以将匿名内部类作为参数

```

```

# 引用类型用法总结
- 基本类型可以作为成员变量 方法参数 方法返回值 引用也是可以的

### class 类作为成员变量

##### 类作为成员变量 对它进行赋值操作 实际上 是付给他该类对象

### 接口作为成员变量
接口作为成员变量 对它进行赋值操作 实际上赋给它该接口的子类的对象

### 接口作为方法的参数和返回值类型
当接口作为方法的参数和返回值类型 传递和返回的都是它的子类对象

> 接口作为参数时，它传递的是子类对象
接口作为返回值类型时，它返回的是子类对象